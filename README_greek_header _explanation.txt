Υλοποίηση Συστημάτων Βάσεων Δεδομένων - Εργασία 1

Δημήτρης Γεωργαντόπουλος sdi1900036
Γιώργος Παλληκάρης sdi1400335



******************************************
HEAPFILE:
******************************************


  #######
hp_file.h
Η δομή HP_info περιέχει γενικές πληροφορίες που αφορούν το ίδιο το αρχείο μας, και σώζεται πάντα στην "αρχή" του block0 αποκλειστικά. Εμπεριέχει το fileDescriptor του αρχείου για εύκολη πρόσβαση σε αυτό, το id του τελευταίου block το οποίο έχουμε, το νούμερο του block στο οποίο βρίσκεται η δομή 
(πάντα 0 προφανώς, αλλά γίνεται για χάρη expandability), maxRecords, όπου αποτελεί τον μέγιστο αριθμό από records που χωράνε σε ένα block,και το fileType, όπου στη προκειμένη εργασία θα είναι 0 για heapfile και 1 για hashtable.

Η δομή HP_block_info εμπεριέχει μεταδεδομένα που αφορούν το κάθε block ξεχωριστά, και αποθηκεύεται στο "τέλος" του block. Εμπεριέχει τον αριθμό από records τα οποία ήδη βρίσκονται μέσα στο block, τον αριθμό του block(αποτέλεσμα της getBlock_counter) αλλά και έναν δείκτη που δείχνει στο "επόμενο" 
block.
  #######
hp_file.c
  #######
HP_CreateFile
Ο μέγιστος αριθμός από records που χωράνε σε ενα block είναι η διαφορά μεταξύ του ίδιου του μεγέθους του block με το μέγεθος του block_info, διαιρεμένη με το μέγεθος του κάθε record. Το index_offset είναι η το offset που θα αξιοποιούμε στη memcpy για την αντιγραφή του block_info σε ένα τυχόν 
νέο μας block, ενώ το ptr_offset η "θέση" που βρίσκεται στο block ο δείκτης προς το επόμενο. Δημιουργούμε και ανοίγουμε αρχείο με όνομα αυτό του ορίσματος της συνάρτησης, σώζοντας το filedescriptor του στη μεταβλητή fileIndex. Αρχικοποιούμε και δεσμεύουμε χώρο για το block0 του αρχείου μας, 
ενημερώνοντας αναλόγως και τα πεδία, τόσο του HP_info και του HP_block_info. Αυτό γίνεται δημιουργώντας δυο μεταβλητές αντίστοιχου τύπου, ενημερώνοντας τα πεδία τους, και μετά κάνοντας τες mecpy στην αρχή και στο τέλος του block0 αντιστοίχως. Εν τέλει, το κάνω dirty και unpin αφού έχω σταματήσει 
τις διεργασίες σε αυτό.
  #######
HP_OpenFile
Μέσω της bf_OpenFile ανοίγουμε το αρχείο ονόματι fileName, και σώζουμε το filedescriptor του στο fileIndex. Παράλληλα, μέσω της getBlock δίνοντας της ως όρισμα 0 στο blockNum, λαμβάνουμε στη μεταβλητή blockvar το πρώτο block του αρχείου μας. Μέσω της getData λαμβάνουμε ένα δείκτη στα δεδομένα του 
block, και κάνουμε memcpy στη δομή HP_info τα δεδομένα του block0, από την αρχή του, μεγέθους HP_info, εν τέλει επιστρέφοντας την δομή πληροφοριών του αρχείου.
  #######

HP_CloseFile
Λαμβάνουμε το αντίστοιχο fileDescriptor του αρχείου το οποίου θέλουμε να κλείσουμε από τη δομή-όρισμα της συνάρτησης, και μέσω της BF_CloseFile, κάνουμε ακριβώς αυτό, ταυτοχρόνως αποδεσμεύοντας τον χώρο που καταλάμβανε η δομή της παραμέτρου.
  #######

HP_InsertEntry
Στη προκειμένη συνάρτηση θα αξιοποιούμε δυο μεταβλητές τύπου BF_Block blockvar και newblock, που θα αξιοποιούνται για την αξιοποίηση του block0. 
Μέσω getBlock με όρισμα 0 και της getData, έχουμε πρόσβαση στα δεδομένα του πρώτου block, και σώζουμε τις πληροφορίες του αρχείου(οι οποίες είναι σωσμένες σε δομή τύπου HP_info), και τις μεταφέρουμε στο dummy_info για ευκολότερη πρόσβαση, σώζοντας τις πληροφορίες εν τέλει σε τοπικές μεταβλητές. Σε 
περίπτωση που υπάρχει στο αρχείο μόνο το block0, τότε απαιτείται η δημιουργία ενός νέο block για την αποθήκευση του Record(εφόσον block0 δεν φυλάσσει εγγραφές). Δεσμεύουμε τον απαραίτητο χώρο μέσω της allocateBlock  για το νέο αυτό block, και μέσω της getBlockCounter μαθαίνουμε τον αριθμό του. 
Δημιουργούμε δομή τύπου HP_block_info, και εφόσον ενημερώσουμε κατάλληλα τα πεδία της που αφορούν το block, την "αντιγράφουμε" στο τέλος του, με τη βοήθεια του index_offset που έχει περιγραφεί προηγουμένως. Παράλληλα, στην αρχή-αρχή του block τοποθετούμε το αντίστοιχο record που θέλουμε να εισαχθεί 
(εφόσον blocks πέραν του block0 δεν έχουν HP_info και είμαστε στην περίπτωση που δεν υπήρχε κανένα άλλο block, άρα και δεν έχει υπάρξει προηγούμενο entry). Καθώς έληξαν οι διεργασίες στο block αυτό, το κάνω dirty και unpin. Εφόσον πλέον έχουμε νεο block, πρέπει να ενημερώσω και τα αντίστοιχα πεδία 
στη δομή HP_info του block0. Αλλάζω πρώτα τον αριθμό των blocks (βρίσκεται ενα integer μετά από την "αρχή"), αλλά και τον δείκτη του block0, ο οποίος τώρα "δείχνει" στο τωρινό μας block. Σε περίπτωση που υπάρχει ήδη άλλο block πέραν του μηδενικού, πρέπει να ελέγξουμε αν το εσωτερικό του έχει φτάσει 
στο ανώτατο όριο από records. Αν δεν έχει φτάσει, τότε απλώς κάνουμε memcpy το record όρισμα current_record_counter*sizeof(Record) θέσεις "δεξιά" απο την αρχή του τωρινού μας block, αυξάνοντας ταυτοχρόνως την μεταβλητή που αποθηκεύει τον αριθμό από entries. Εφόσον έχουν λήξει οι διεργασίες στο συγκεκριμένο
 block, το κάνουμε unpin και dirty. Τέλος, σε περίπτωση που το block έχει φτάσει στη μέγιστη χωρητικότητα του από records, υπάρχει η ανάγκη δημιουργίας νέου block. Ακολουθώ διαδικασία παρόμοια με την περίπτωση που υπάρχει μόνο block0, κάνοντας το "προηγούμενο" block να δείχνει στο τωρινό new_last μέσω 
 της memcpy. Παράλληλα, λαμβάνω τον αναγνωριστικό αριθμό του νέου μας μπλοκ μέσω της GetBlockCounter, ενημερώνοντας το νούμερο του τελευταίου διαθέσιμου block στα μεταδεδομένα του block0 για τις πληροφορίες του αρχείου. Εν τέλει, κάνουμε memcpy στην αρχή του νέου μας block το record όρισμα, και στο τέλος 
 του, δομή τύπου block_info με τις κατάλληλες πληροφορίες.
 
 
  #######
HP_GetAllEntries
Αρχικά μέσω getBlockCounter λαμβάνουμε τον αριθμό υπάρχοντων blocks. Για κάθε ένα από αυτά, λαμβάνουμε το ίδιο και τα δεδομένα του μέσω των GetBlock και BF_Block_GetData αντιστοίχως. Στη "πρώτη θέση" του HP_blockInfo βρίσκεται η μεταβλητή recordsCounter, που μετράει τον αριθμό από entries στο block. Μέσω 
ης memcpy σώζουμε αυτό στη τοπικη μεταβλητή recordsinblock, όπου για κάθε ενα entry στο block, λαμβάνω το id του και το σώζω στη μεταβλητή temp_key. Βλέποντας το struct record, αυτό βρίσκεται ακριβώς μετά το char record[15], γιαυτό και στη memcpy λαμβάνουμε μέγεθος sizeof(int) bytes από j*sizeof(record)+
16*sizeof(char). Σε περίπτωση που το κλειδί, ισούται με το όρισμα της συνάρτησης τότε τυπώνουμε το ίδιο το record.






******************************************
HASH TABLE:
******************************************

  #######
ht_table.h
Η δομή HΤ_block_info εμπεριέχει μεταδεδομένα που αφορούν το κάθε block ξεχωριστά, και αποθηκεύεται στο "τέλος" του block. Εμπεριέχει τον αριθμό από records τα οποία ήδη βρίσκονται μέσα στο block, τον αριθμό του block(αποτέλεσμα της getBlock_counter) έναν δείκτη που δείχνει στο "επόμενο" block,αλλά και ένα 
integer με το ID του block αυτού.

  #######
Η δομή HΤ_info περιέχει γενικές πληροφορίες που αφορούν το ίδιο το αρχείο μας, και σώζεται πάντα στην "αρχή" του block0 αποκλειστικά. Εμπεριέχει το fileDescriptor του αρχείου για εύκολη πρόσβαση σε αυτό,numBuckets, όπου είναι ο αριθμός των κάδων κατακερματισμού (όπως υποδεικνύει και η εκφώνηση),το νούμερο του
 block στο οποίο βρίσκεται η δομή (πάντα 0 προφανώς, αλλά γίνεται για χάρη expandability), maxRecords, όπου αποτελεί τον μέγιστο αριθμό από records που χωράνε σε ένα block,και το fileType, όπου στη προκειμένη περίπτωση είναι 1, για hashtable.Το ht_index_buckets αποτελεί πίνακα ο οποίος εμπεριέχει τα ids του πιο
  πρόσφατα ιδρυμένου block για κάθε bucket, ενώ το ht_index_ptrs περιλαμβάνει δείκτη στη σελίδα που τοποθετήθηκε το τελευταίο block στο εκάστοτε bucket (να σημειωθεί οτι δεν είναι ο σωστός τρόπος πλοήγησης). Ταυτόχρονα, το indexOffset αποτελεί το offset το οποίο "δείχνει" στην αρχή της δομής HT_block_info, 
  η οποία βρίσκεται στο τέλος του κάθε block, ενώ το ptrOffset αξιοποιείται για την πρόσβαση στη στον δείκτη του επόμενου block, ενώ ο πίνακας HT_INDEX_RECS αποθηκεύει τον αριθμό από records που αντιστοιχούν στο κάθε bucket.

  #######
ht_table.c
HT_CreateFile
Ο μέγιστος αριθμός από records που χωράνε σε ενα block είναι η διαφορά μεταξύ του ίδιου του μεγέθους του block με το μέγεθος του block_info, διαιρεμένη με το μέγεθος του κάθε record. Το index_offset είναι η το offset που θα αξιοποιούμε στη memcpy για την αντιγραφή του ht_block_info σε ένα τυχόν νέο μας 
block, ενώ το ptr_offset η "θέση" που βρίσκεται στο block ο δείκτης προς το επόμενο. Δημιουργούμε και ανοίγουμε αρχείο με όνομα αυτό του ορίσματος της συνάρτησης, σώζοντας το filedescriptor του στη μεταβλητή fileIndex. Αρχικοποιούμε και δεσμεύουμε χώρο για το block0 του αρχείου μας, ενημερώνοντας αναλόγως
 και τα πεδία, τόσο του HT_info και του HT_block_info. Αυτό γίνεται δημιουργώντας δυο μεταβλητές αντίστοιχου τύπου, ενημερώνοντας τα πεδία τους, και μετά κάνοντας τες mecpy στην αρχή και στο τέλος του block0 αντιστοίχως. Παράλληλα, για κάθε ένα από τα buckets, αρχικοποιώ τις τιμές των πινάκων που έχω στη 
 μεταβλητή header_info (τύπου HT_Block_info), την HT_INDEX_BUCKETS με -1 εφόσον δεν υπάρχουν δημιουργημένα block,την HT_INDEX_PTRS με NULL (εφόσον δεν έχουμε σε κάποιο block να αντιστοιχεί στο bucket) και την HT_INDEX_RECS με 0 (εφόσον έχουμε 0 records).Εν τέλει, κάνω dirty το block0 και unpin αφού έχω 
 σταματήσει τις διεργασίες σε αυτό, κάνοντας μετά close το ίδιο το αρχείο.


  #######
HT_OpenFile
Μέσω της bf_OpenFile ανοίγουμε το αρχείο ονόματι fileName, και σώζουμε το filedescriptor του στο fileIndex. Παράλληλα, μέσω της getBlock δίνοντας της ως δύτερο όρισμα το 0 στο blockNum, λαμβάνουμε στη μεταβλητή blockvar το πρώτο block του αρχείου μας. Μέσω της getData λαμβάνουμε ένα δείκτη στα δεδομένα
 του block, και κάνουμε memcpy στη δομή HΤ_info τα δεδομένα του block0 από την αρχή του, μεγέθους HΤ_info, εν τέλει επιστρέφοντας την δομή πληροφοριών του αρχείου.

  #######
HT_CloseFile
Λαμβάνουμε το αντίστοιχο fileDescriptor του αρχείου το οποίου θέλουμε να κλείσουμε από τη δομή-όρισμα της συνάρτησης, και μέσω της BF_CloseFile, κάνουμε ακριβώς αυτό, ταυτοχρόνως αποδεσμεύοντας τον χώρο που καταλάμβανε η δομή της παραμέτρου.

  #######
HT_InsertEntry
Αρχικά, σώζω τις πληροφορίες του αρχείου μας που έχει η HT_info που περνιέται ως όρισμα της συνάρτησης σε τοπικές μεταβλητές, και φορτώνω στη μνήμη το block νούμερο 0, στη μεταβλητή τύπου BF_Block ονόματι blockvar μέσω της BF_GetBlock. Ταυτόχρονα, σώζουμε τη δομή HT_info μέσω memcpy σε τοπική δομή-μεταβλητή 
ονόματι dummy_info για ευκολότερη πρόσβαση, σώζοντας ταυτόχρονα το πλήθος των κάδων και την χωρητικότητα του κάθε block. Εφαρμόζω την συνάρτηση κατακερματισμού στο πεδίο id(κάνοντας mod έτσι ώστε το αποτέλεσμα να αποδοθεί στο σωστό αριθμό που αναλογεί στα υπάρχοντα buckets).Ταυτόχρονα, δημιουργούμε μεταβλητή 
index_info τύπου HT_Block_info και την αρχικκοποιούμε σε ορισμένα πεδία έτσι ώστε να γίνεται γρήγορα η "αντιγραφή" της μέσω memcpy στο τέλος του κάθε block, όταν αυτό δημιυοργείται. Σε περίπτωση που δεν υπάρχει κανένα δημιουργημένο block στο αντίστοιχο bucket, δημιουργώ ένα νέο μέσω της allocate, και με τη
 βοήθεια της getBlockCounter ενημερώνω το αντίστοιχο πεδίο της δομής index_info,όπου και την "κολλάω" στο τέλος του block. Μέσω memcpy αντιγράφω το ίδιο το record στην αρχή του block(εφόσον βρισκόμαστε στη περίπτωση που το block μόλις δημιουργήθηκε), κάνοντας το ταυτοχρόνως unpin εφόσον τελείωσα τις διεργασίες
  σε αυτό. Σε περίπτωση που υπάρχει ήδη block που αντιστοιχεί στο συγκεκριμένο bucket, αρχικά το "φορτώνουμε" στη μεταβλητή lastblock τύπου BF_Block, έχοντας το lastdata να δείχνει στην αρχή του. Ταυτόχρονα, λαμβάνουμε δεδομένα μεγέθους ΗΤ_Block_info από το τέλος του block, και τα σώζουμε στη τοπική μεταβλητή
   lastblockindex για ευκολότερη πρόσβαση. Έχοντας πλέον τα μεταδεδομένα του block, ελέγχουμε τον αριθμό του από entries. Σε περίπτωση που ο αριθμός από records είναι μικρότερος απ'τον μέγιστο επιτρεπτό, δηλαδή χωράει κιάλλο entry, τότε μέσω memcpy αντιγράφω το record, τόσες θέσεις απτην αρχή του block, 
   όσο ο αριθμός των records(πολλαπλασιασμένος προφανώς με το ίδιο το μέγεθος του record αφού μιλάμε για θέσεις μνήμης). Αυξάνω τη μεταβλητή που κρατάει των αριθμό των records, αντιγράφοντας τη στη κατάλληλη θέση, στη δομή του block, HT_block_info. Το id του block που σώζεται στη HT_INDEX_BUCKETS αποτελεί 
   ουσιαστικά τον ίδιο τον αριθμό του, γιαυτό και σώζουμε στη μεταβλητή counter τη θέση του πίνακα, ενημερώνοντας ταυτόχρονα τον HT_INDEX_PTRS να "δείχνει" στο δικό μας α////////////////.
Ακόμα, αφού τελειώσαμε τις διεργασίες στο block, το κάνουμε dirty και unpin. Στη περίπτωση όπου το block μας είναι γεμάτο από εγγραφές, τότε δημιουργούμε καινούργιο, μέσω της allocate,ενημερώνουμε τα αντίστοιχα πεδία της index_info και την "κολλάμε" μέσω memcpy και του αντίστοιχου offset στο τέλος του block.
 Ετσι, απλώς αντιγράφουμε το record στην αρχή του block,ενημερώνοντας ταυτόχρονα τον HT_INDEX_PTRS να "δείχνει" στο πιο πρόσφατο block, και το HT_INDEX_BUCKETS να έχει το id του δημιουργηθέντος block. Τέλος, σε κάθε περίπτωση αυξάνουμε τον αριθμό των records κατά 1 στο αντίστοιχο bucket, και "γράφουμε" την 
 dummy_info που έχουμε αλλάξει στη δομή-όρισμα ht_info. Εκτυπώνουμε το ίδιο το record, και μετά αντιγραφουμε τη δομή dummy_info στη σωστή θέση (δηλαδή στην αρχή του block0).


  #######
HT_GetAllEntries
Λαμβάνουμε το filedescriptor του αρχείου από τη δομή-όρισμα, και με τη βοήθεια των GetBlock και GetData λαμβάνουμε το HT_info από την αρχή του block 0, αντιγράφοντάς το για ευκολία πρόσβασης σε τοπική μεταβλητή ονόματι dummy_info, σώζοντας τα μεταδεδομένα που περιέχει σε άλλες τοπικές μεταβλητές. Καλούμε την 
hash_function με το value που μας έχει δοθεί ως όρισμα (το έχουμε κάνει cast σε int* keyset). Σε περίπτωση που το bucket έχει είναι άδειο, τότε προφανώς δεν υπάρχει άτομο με τέτοιο id. Σε περίπτωση που έχει τουλάχιστον ενα entry, λαμβάνουμε το αντίστοιχο id του block που αντιστοιχεί στο συγκεκριμένο bucket, 
και σώζουμε το ht_block_info στην index_var για ευκολότερη πρόσβαση στα μεταδεδομένα, έτσι ώστε να γνωρίζουμε τον αριθμό απο blocks που βρίσκονται μέσα στο bucket. Για κάθε ένα από τα blocks, για κάθε ένα από τα records στο συγκεκριμένο block, μέσω της memcpy σώζω στο tempkey τη μεταβλητή id του κάθε record 
(εφόσον στην ίδια τη δομή, αυτή βρίσκεται ακριβώς μετά από το record[15]). και το ίδιο το record προς εκτύπωση στην toprintRec, τυπώνοντας το. Αλλάζω τη τιμή του flag fl, το οποίο απλώς υπάρχει για την σηματοδότηση εύρεσης ή οχι του επιθυμητού entry. Σε περίπτωση που υπάρχουν και άλλα blocks, τo λαμβάνουμε μέσω 
του getBlockId και το σώζουμε στο blockvar, ενημερώνοντας οτι πλέον αυτό είναι το block που εξετάζεται και ανανεώνοντας το index_var ώστε να έχει τα μεταδεδομένα για το σωστό block.


******************************************
